lambda_cred_int <- lambda_summary[parameter, c("2.5%", "97.5%")]
writeLines(sprintf('
Mean of %s: %.3f
SD of %s: %.3f
95%% credibility interval: [ %.3f , %.3f ]',
parameter,lambda_mean, parameter, lambda_sd, lambda_cred_int[1], lambda_cred_int[2]
))
}
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 116
y <- 11
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (1, 10);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 3 ,
iter = 1000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
# Inspecting the chains
inspect_chains <- function(stanFit, stanPosterior, parameter){
rstan :: traceplot (stanFit ,pars=c(parameter)) +
theme_minimal() +
labs(title = paste("Trace Plot of ", parameter),
x = "Iteration",
y = parameter)
mcmcCoda <- mcmc.list( lapply (1:ncol( stanFit ), function (x) { mcmc(stanPosterior[,x ,]) }))
autocorr.plot(mcmcCoda)
# Default plots of the posterior
color_scheme_set("red")
density_plot <- plot(stanFit ,pars=c(parameter))+
theme_minimal() +
labs(title = paste("Posterior Density of ", parameter),
x = parameter,
y = "Density")
print(density_plot)
areas_plot <- mcmc_areas(stanPosterior, pars=c(parameter), point_est = 'mean', prob = 0.95)+
theme_minimal() +
labs(title = paste("Posterior Distribution of ", parameter),
x = parameter,
y = "Density")
print(areas_plot)
hist_plot <- mcmc_hist(stanPosterior, pars=c(parameter)) +
theme_minimal() +
labs(title = paste("Posterior Histogram of ", parameter),
x = parameter,
y = "Frequency")
print(hist_plot)
# --------------- write output ------------------
lambda_summary <- summary(stanFit, pars = parameter)$summary
lambda_mean <- lambda_summary[parameter, "mean"]
lambda_sd <- lambda_summary[parameter, "sd"]
lambda_cred_int <- lambda_summary[parameter, c("2.5%", "97.5%")]
writeLines(sprintf('
Mean of %s: %.3f
SD of %s: %.3f
95%% credibility interval: [ %.3f , %.3f ]',
parameter,lambda_mean, parameter, lambda_sd, lambda_cred_int[1], lambda_cred_int[2]
))
}
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 116
y <- 11
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (1, 10);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 3 ,
iter = 1000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
alpha <- 12
beta <- 115
beta_posterior <- function(p) sapply(p, function(x) dbeta(x, alpha, beta))
mean <- getBetaMean(alpha, beta)
SD   <- getBetaSD  (alpha, beta)
curve(beta_posterior, from = 0, to=1, n = 1000, xlim = c(0,0.3), main="Bayesian posterior of p", xlab="p", ylab = "probability density", col=color_vector[1], lwd=3, ylim = c(0, 16.5))
beta_95_interval <- sapply(c(0.025, 0.975), function(p) qbeta(p, alpha, beta))
x_plot <- seq(beta_95_interval[1], beta_95_interval[2], length.out=1000)
y_plot <- c(0, beta_posterior(x_plot[2:999]), 0)
polygon(x_plot, y_plot, col = adjustcolor(color_vector[5], alpha.f = 0.5), border = NA)
abline(v = mean, col = color_vector[7], lty=2, lwd = 3)
abline(v = mean - SD, col = color_vector[6], lty = 3, lwd = 3)
abline(v = mean + SD, col = color_vector[6], lty = 3, lwd = 3)
legend('topright', legend = c('mean', 'mean ± std'), lty = c(2, 3, 3), lwd=3, col = c(color_vector[7], color_vector[6], color_vector[6]))
legend('right', legend = '95% credibility interval', fill = adjustcolor(color_vector[5], alpha.f = 0.5))
writeLines(sprintf(
'The 95%% credibility interval for the posterior is [ %.3f , %.3f ]', beta_95_interval[1], beta_95_interval[2]))
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 165
y <- 9
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (1, 10);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
inspect_chains(stanFit, stanPosterior, "p")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 165
y <- 9
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (21, 271);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
ns(mc.cores = parallel::detectCores())
inspect_chains(stanFit, stanPosterior, "p")
alpha <- 21
beta <- 271
beta_posterior <- function(p) sapply(p, function(x) dbeta(x, alpha, beta))
mean <- getBetaMean(alpha, beta)
SD   <- getBetaSD  (alpha, beta)
curve(beta_posterior, from = 0, to=1, n = 1000, xlim = c(0,0.17), main="Bayesian posterior of p", xlab="p", ylab = "probability density", col=color_vector[1], lwd=3, ylim = c(0, 30))
beta_95_interval <- sapply(c(0.025, 0.975), function(p) qbeta(p, alpha, beta))
x_plot <- seq(beta_95_interval[1], beta_95_interval[2], length.out=1000)
y_plot <- c(0, beta_posterior(x_plot[2:999]), 0)
polygon(x_plot, y_plot, col = adjustcolor(color_vector[5], alpha.f = 0.5), border = NA)
abline(v = mean, col = color_vector[7], lty=2, lwd = 3)
abline(v = mean - SD, col = color_vector[6], lty = 3, lwd = 3)
abline(v = mean + SD, col = color_vector[6], lty = 3, lwd = 3)
legend('topright', legend = c('mean', 'mean ± std'), lty = c(2, 3, 3), lwd=3, col = c(color_vector[7], color_vector[6], color_vector[6]))
legend('right', legend = '95% credibility interval', fill = adjustcolor(color_vector[5], alpha.f = 0.5))
writeLines(sprintf(
'The 95%% credibility interval for the posterior is [ %.3f , %.3f ]', beta_95_interval[1], beta_95_interval[2]))
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 165
y <- 9
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (12, 115);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
knitr::opts_chunk$set(echo = TRUE)
color_vector <- c("#CC0000",   # Dark red
"#CC79A7",   # Muted purple
"#D55E00",   # Vermilion
"#009E73",   # Bluish green
"#56B4E9",   # Sky blue
'#000046',   # Deep Blue
"#DB1E60",   # Pinkish-red
"#E69F00")   # Yellow-orange
library(dplyr)
library(ggplot2)
library(reshape2)
library(latex2exp)
library(coda)
library(rstan)
library(bayesplot)
#------------- Useful functions -------------
mean_pdf   <- function(f, lower, upper){integrate(function(x) x*f(x), lower, upper,stop.on.error = FALSE)$value}
std_pdf <- function(f, lower, upper) {
mu <- mean_pdf(f, lower, upper)
sqrt(integrate(function(x) (x - mu)^2 * f(x), lower, upper, stop.on.error = FALSE)$value / integrate(f, lower, upper, stop.on.error = FALSE)$value)
}
cumulative <- function(f, lower, X){integrate(f, lower, X,stop.on.error = FALSE)$value}
inverse_cumulative <- function(f, p, lower, upper){uniroot(function(x) cumulative(f, lower, x)-p, c(lower, upper))$root}
#inference functions
binom_likelihood <- function(prob, ...) sapply(prob, function(P)  prod(dbinom(prob=P, ...)))
pois_likelihood  <- function(mu, ...)   sapply(mu,   function(MU) prod(dpois (lambda = MU, ...)))
norm_likelihood  <- function(mu, ...)   sapply(mu,   function(MU) prod(dnorm (mean = MU, ...) ))
posterior <- function(parameter, prior, likelihood, lower, upper, ...) {
unnormalized <- function(x) likelihood(x, ...)*prior(x)
norm_factor  <- integrate(unnormalized, lower = lower, upper = upper)$value
unnormalized(parameter)/norm_factor
}
getBetaMean  <- function (alpha, beta) alpha/(alpha+beta)
getBetaSD    <- function (alpha, beta) sqrt(alpha*beta/(alpha+beta+1))/(alpha+beta)
getGammaMean <- function (alpha, beta) alpha/beta
getGammaSD   <- function (alpha, beta) sqrt(alpha)/beta
plot_exe1 <- function(alpha, beta){
gamma_posterior_1   <- function(p) sapply(p, function(P) dgamma(P, alpha[1], rate=beta[1]))
gamma_posterior_2   <- function(p) sapply(p, function(P) dgamma(P, alpha[2], rate=beta[2]))
mean <- mapply(getGammaMean, alpha, beta)
SD   <- mapply(getGammaSD, alpha, beta)
curve(gamma_posterior_1, from = 0, to=1, n = 1000, xlim = c(0.4, 1), main="Bayesian posterior of Lambda", xlab=expression(lambda), ylab = "probability density", col=color_vector[1], lwd=3, ylim = c(0, 10))
curve(gamma_posterior_2, from = 0, to=1, n = 1000, col=color_vector[6], lwd=3, lty=2, add = TRUE)
gamma_95_interval <- mapply(function(A, B) sapply(c(0.025, 0.975), function(p) qgamma(p, A, rate=B)), alpha, beta)
x_plot_1 <- seq(from = gamma_95_interval[1,1], to = gamma_95_interval[2,1], length.out=1000)
y_plot_1 <- c(0, gamma_posterior_1(x_plot_1[2:999]), 0)
x_plot_2 <- seq(from = gamma_95_interval[1,2], to = gamma_95_interval[2,2], length.out=1000)
y_plot_2 <-  c(0, gamma_posterior_2(x_plot_2[2:999]), 0)
polygon(x_plot_1, y_plot_1, col = adjustcolor(color_vector[1], alpha.f = 0.4), border = NA)
polygon(x_plot_2, y_plot_2, col = adjustcolor(color_vector[6], alpha.f = 0.4), border = NA)
abline(v = mean[1], col = color_vector[7], lty=2, lwd = 3)
abline(v = mean[2], col = color_vector[5], lty=2, lwd = 3)
legend('topright', legend = c('Set 1', 'Set 2'), lty = c(1, 2), lwd=3, col = c(color_vector[1], color_vector[6]))
writeLines(sprintf('
The 95%% credibility interval for the posterior of Set 1 is [ %.3f , %.3f ]
The 95%% credibility interval for the posterior of Set 2 is [ %.3f , %.3f ]',
gamma_95_interval[1,1], gamma_95_interval[2,1], gamma_95_interval[1,2], gamma_95_interval[2,2]))
return()
}
alpha <- c(123, 197)
beta  <- c(200, 280)
plot_exe1(alpha, beta)
alpha <- c(122.5, 196)
beta  <- c(200.5, 280)
plot_exe1(alpha, beta)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
occurencies <- c(109, 65, 22, 3, 1)
indices <- c(0, cumsum(occurencies))
observations <- vector(length = sum(occurencies))
for(i in seq_along(occurencies)){
for(j in (indices[i]+1):indices[i+1]){
observations[j] <- i-1
}
}
N = length(observations)
dataList= list(N=N, y = observations)
modelString =
"
data {
int <lower=0> N;
int y[N];
}
parameters {
real <lower=0> Lambda;
}
model {
y ~ poisson (Lambda);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
# Inspecting the chains
inspect_chains <- function(stanFit, stanPosterior, parameter){
rstan :: traceplot (stanFit ,pars=c(parameter)) +
theme_minimal() +
labs(title = paste("Trace Plot of ", parameter),
x = "Iteration",
y = parameter)
mcmcCoda <- mcmc.list( lapply (1:ncol( stanFit ), function (x) { mcmc(stanPosterior[,x ,]) }))
autocorr.plot(mcmcCoda)
# Default plots of the posterior
color_scheme_set("red")
density_plot <- plot(stanFit ,pars=c(parameter))+
theme_minimal() +
labs(title = paste("Posterior Density of ", parameter),
x = parameter,
y = "Density")
print(density_plot)
areas_plot <- mcmc_areas(stanPosterior, pars=c(parameter), point_est = 'mean', prob = 0.95)+
theme_minimal() +
labs(title = paste("Posterior Distribution of ", parameter),
x = parameter,
y = "Density")
print(areas_plot)
hist_plot <- mcmc_hist(stanPosterior, pars=c(parameter)) +
theme_minimal() +
labs(title = paste("Posterior Histogram of ", parameter),
x = parameter,
y = "Frequency")
print(hist_plot)
# --------------- write output ------------------
lambda_summary <- summary(stanFit, pars = parameter)$summary
lambda_mean <- lambda_summary[parameter, "mean"]
lambda_sd <- lambda_summary[parameter, "sd"]
lambda_cred_int <- lambda_summary[parameter, c("2.5%", "97.5%")]
writeLines(sprintf('
Mean of %s: %.3f
SD of %s: %.3f
95%% credibility interval: [ %.3f , %.3f ]',
parameter,lambda_mean, parameter, lambda_sd, lambda_cred_int[1], lambda_cred_int[2]
))
}
inspect_chains(stanFit, stanPosterior, "Lambda")
modelString_Jeffrey =
"
data {
int <lower=0> N;
int y[N];
}
parameters {
real <lower=0> Lambda;
}
model {
target += -0.5*log(Lambda);
y ~ poisson (Lambda);
}
"
stanDso_Jeffrey <- stan_model ( model_code = modelString_Jeffrey )
stanFit_Jeffrey <- sampling ( object = stanDso_Jeffrey ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior_Jeffrey <- as.array(stanFit_Jeffrey)
inspect_chains(stanFit_Jeffrey, stanPosterior_Jeffrey, "Lambda")
alpha <- 12
beta <- 115
beta_posterior <- function(p) sapply(p, function(x) dbeta(x, alpha, beta))
mean <- getBetaMean(alpha, beta)
SD   <- getBetaSD  (alpha, beta)
curve(beta_posterior, from = 0, to=1, n = 1000, xlim = c(0,0.3), main="Bayesian posterior of p", xlab="p", ylab = "probability density", col=color_vector[1], lwd=3, ylim = c(0, 16.5))
beta_95_interval <- sapply(c(0.025, 0.975), function(p) qbeta(p, alpha, beta))
x_plot <- seq(beta_95_interval[1], beta_95_interval[2], length.out=1000)
y_plot <- c(0, beta_posterior(x_plot[2:999]), 0)
polygon(x_plot, y_plot, col = adjustcolor(color_vector[5], alpha.f = 0.5), border = NA)
abline(v = mean, col = color_vector[7], lty=2, lwd = 3)
abline(v = mean - SD, col = color_vector[6], lty = 3, lwd = 3)
abline(v = mean + SD, col = color_vector[6], lty = 3, lwd = 3)
legend('topright', legend = c('mean', 'mean ± std'), lty = c(2, 3, 3), lwd=3, col = c(color_vector[7], color_vector[6], color_vector[6]))
legend('right', legend = '95% credibility interval', fill = adjustcolor(color_vector[5], alpha.f = 0.5))
writeLines(sprintf(
'The 95%% credibility interval for the posterior is [ %.3f , %.3f ]', beta_95_interval[1], beta_95_interval[2]))
# Frequentist test
binom.test(x=11, n = 116, p = 0.1, alternative = "two.sided")
# Frequentist test
binom.test(x=9, n = 165, p = 0.1, alternative = "two.sided")
alpha <- 21
beta <- 271
beta_posterior <- function(p) sapply(p, function(x) dbeta(x, alpha, beta))
mean <- getBetaMean(alpha, beta)
SD   <- getBetaSD  (alpha, beta)
curve(beta_posterior, from = 0, to=1, n = 1000, xlim = c(0,0.17), main="Bayesian posterior of p", xlab="p", ylab = "probability density", col=color_vector[1], lwd=3, ylim = c(0, 30))
beta_95_interval <- sapply(c(0.025, 0.975), function(p) qbeta(p, alpha, beta))
x_plot <- seq(beta_95_interval[1], beta_95_interval[2], length.out=1000)
y_plot <- c(0, beta_posterior(x_plot[2:999]), 0)
polygon(x_plot, y_plot, col = adjustcolor(color_vector[5], alpha.f = 0.5), border = NA)
abline(v = mean, col = color_vector[7], lty=2, lwd = 3)
abline(v = mean - SD, col = color_vector[6], lty = 3, lwd = 3)
abline(v = mean + SD, col = color_vector[6], lty = 3, lwd = 3)
legend('topright', legend = c('mean', 'mean ± std'), lty = c(2, 3, 3), lwd=3, col = c(color_vector[7], color_vector[6], color_vector[6]))
legend('right', legend = '95% credibility interval', fill = adjustcolor(color_vector[5], alpha.f = 0.5))
writeLines(sprintf(
'The 95%% credibility interval for the posterior is [ %.3f , %.3f ]', beta_95_interval[1], beta_95_interval[2]))
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 116
y <- 11
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (1, 10);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 165
y <- 9
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (1, 10);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
n <- 165
y <- 9
dataList= list(n=n, y = y)
modelString  =
"
data {
int <lower=0> n;
int <lower=0> y;
}
parameters {
real <lower=0, upper=1> p;
}
model {
p ~ beta (12, 115);
y ~ binomial (n, p);
}
"
stanDso <- stan_model ( model_code = modelString )
stanFit <- sampling ( object = stanDso ,
data = dataList ,
chains = 2 ,
iter = 5000 ,
warmup = 200 ,
thin = 1)
stanPosterior <- as.array(stanFit)
inspect_chains(stanFit, stanPosterior, "p")
